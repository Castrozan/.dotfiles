#!/usr/bin/env bash
# ia-work: Process Obsidian notes with AI instructions
# Scans vault for notes with ia-work/ework tags and executes AI instructions

set -euo pipefail

# Configuration defaults (can be overridden via environment)
VAULT_PATH="${IA_WORK_VAULT_PATH:-$HOME/vault}"
AI_CLI="${IA_WORK_AI_CLI:-claude -p}"
TAG_NAME="${IA_WORK_TAG:-ia-work}"
HOURS_BACK="${IA_WORK_HOURS:-24}"
ENSURE_OBSIDIAN="${IA_WORK_ENSURE_OBSIDIAN:-false}"
DRY_RUN="${IA_WORK_DRY_RUN:-false}"
VERBOSE="${IA_WORK_VERBOSE:-false}"
PROCESSED_MARKER="ia-work-processed"
LOG_DIR="${IA_WORK_LOG_DIR:-$HOME/.local/state/ia-work}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    local level="$1"
    shift
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    case "$level" in
        INFO)  [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[$timestamp]${NC} $*" ;;
        WARN)  echo -e "${YELLOW}[$timestamp] WARN:${NC} $*" >&2 ;;
        ERROR) echo -e "${RED}[$timestamp] ERROR:${NC} $*" >&2 ;;
        OK)    echo -e "${GREEN}[$timestamp]${NC} $*" ;;
        *)     echo -e "[$timestamp] $*" ;;
    esac
}

usage() {
    cat <<EOF
Usage: ia-work [OPTIONS]

Scans Obsidian vault for notes with AI work tags and executes instructions.

Options:
    -v, --vault PATH       Vault path (default: \$HOME/vault)
    -c, --cli COMMAND      AI CLI command (default: claude -p)
    -t, --tag TAG          Tag to search for (default: ia-work)
    -h, --hours N          Look back N hours (default: 24)
    -o, --obsidian         Ensure Obsidian is running before processing
    -d, --dry-run          Show what would be done without executing
    -V, --verbose          Enable verbose output
    --help                 Show this help message

Environment Variables:
    IA_WORK_VAULT_PATH     Same as --vault
    IA_WORK_AI_CLI         Same as --cli
    IA_WORK_TAG            Same as --tag
    IA_WORK_HOURS          Same as --hours
    IA_WORK_ENSURE_OBSIDIAN Same as --obsidian
    IA_WORK_DRY_RUN        Same as --dry-run
    IA_WORK_VERBOSE        Same as --verbose
    IA_WORK_LOG_DIR        Directory for logs (default: ~/.local/state/ia-work)

Note Format:
    Notes should have YAML frontmatter with the tag and an instruction section:

    ---
    tags:
      - ia-work
    ---

    # Note Title

    ## AI Instructions
    Your instructions here...
    They can span multiple lines.
    ## End AI Instructions

    Or use inline tags: [[ia-work]]
    With HTML comments: <!-- AI: instructions here -->

Examples:
    ia-work --verbose --dry-run
    ia-work --vault ~/notes --tag ework --hours 12
    IA_WORK_AI_CLI="opencode -p" ia-work
EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -v|--vault)
            VAULT_PATH="$2"
            shift 2
            ;;
        -c|--cli)
            AI_CLI="$2"
            shift 2
            ;;
        -t|--tag)
            TAG_NAME="$2"
            shift 2
            ;;
        -h|--hours)
            HOURS_BACK="$2"
            shift 2
            ;;
        -o|--obsidian)
            ENSURE_OBSIDIAN="true"
            shift
            ;;
        -d|--dry-run)
            DRY_RUN="true"
            shift
            ;;
        -V|--verbose)
            VERBOSE="true"
            shift
            ;;
        --help)
            usage
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            usage
            exit 1
            ;;
    esac
done

# Ensure log directory exists
mkdir -p "$LOG_DIR"

ensure_obsidian_running() {
    if [[ "$ENSURE_OBSIDIAN" != "true" ]]; then
        return 0
    fi

    log INFO "Checking if Obsidian is running..."

    if pgrep -x obsidian >/dev/null 2>&1; then
        log INFO "Obsidian is already running"
        return 0
    fi

    log INFO "Starting Obsidian..."
    if [[ "$DRY_RUN" == "true" ]]; then
        log INFO "[DRY RUN] Would start Obsidian"
        return 0
    fi

    # Start Obsidian in background
    nohup obsidian >/dev/null 2>&1 &

    # Wait for Obsidian to start and sync (give it time)
    local wait_time=30
    log INFO "Waiting ${wait_time}s for Obsidian to start and sync..."
    sleep "$wait_time"

    if pgrep -x obsidian >/dev/null 2>&1; then
        log OK "Obsidian started successfully"
        return 0
    else
        log WARN "Obsidian may not have started properly"
        return 1
    fi
}

# Check if note has the target tag (YAML frontmatter or inline)
has_tag() {
    local file="$1"
    local content
    content=$(cat "$file")

    # Check YAML frontmatter tags
    if echo "$content" | head -50 | grep -qE "^tags:" ; then
        # Look for tag in YAML list format
        if echo "$content" | head -50 | grep -qE "^\s*-\s*${TAG_NAME}\s*$"; then
            return 0
        fi
        # Look for tag in YAML array format: tags: [tag1, tag2]
        if echo "$content" | head -50 | grep -qE "^tags:\s*\[.*${TAG_NAME}"; then
            return 0
        fi
    fi

    # Check inline tags [[tag]]
    if echo "$content" | grep -qE "\[\[${TAG_NAME}\]\]"; then
        return 0
    fi

    # Check hashtag style #tag
    if echo "$content" | grep -qE "#${TAG_NAME}(\s|$)"; then
        return 0
    fi

    return 1
}

# Check if note has already been processed
is_processed() {
    local file="$1"
    local content
    content=$(cat "$file")

    # Check for processed marker in frontmatter or content
    if echo "$content" | grep -qE "^\s*-\s*${PROCESSED_MARKER}\s*$"; then
        return 0
    fi
    if echo "$content" | grep -qE "\[\[${PROCESSED_MARKER}\]\]"; then
        return 0
    fi
    if echo "$content" | grep -qE "#${PROCESSED_MARKER}(\s|$)"; then
        return 0
    fi
    # Check for HTML comment marker
    if echo "$content" | grep -qE "<!--\s*${PROCESSED_MARKER}"; then
        return 0
    fi

    return 1
}

# Extract AI instructions from note
extract_instructions() {
    local file="$1"
    local content
    content=$(cat "$file")
    local instructions=""

    # Method 1: ## AI Instructions ... ## End AI Instructions
    if echo "$content" | grep -qE "^##\s*AI Instructions"; then
        instructions=$(echo "$content" | sed -n '/^## AI Instructions/,/^## End AI Instructions/p' | \
                      sed '1d;$d' | sed '/^$/d')
        if [[ -n "$instructions" ]]; then
            echo "$instructions"
            return 0
        fi
    fi

    # Method 2: <!-- AI: instructions --> (single or multi-line)
    instructions=$(echo "$content" | grep -oP '<!--\s*AI:\s*\K.*?(?=\s*-->)' | head -1)
    if [[ -n "$instructions" ]]; then
        echo "$instructions"
        return 0
    fi

    # Method 3: Multi-line HTML comment <!-- AI: \n instructions \n -->
    instructions=$(echo "$content" | perl -0777 -ne 'print $1 if /<!--\s*AI:\s*(.*?)\s*-->/s' | head -50)
    if [[ -n "$instructions" ]]; then
        echo "$instructions"
        return 0
    fi

    # Method 4: Code block with ai-instructions language
    instructions=$(echo "$content" | sed -n '/^```ai-instructions/,/^```$/p' | sed '1d;$d')
    if [[ -n "$instructions" ]]; then
        echo "$instructions"
        return 0
    fi

    return 1
}

# Mark note as processed
mark_processed() {
    local file="$1"
    local timestamp
    timestamp=$(date '+%Y-%m-%dT%H:%M:%S')

    if [[ "$DRY_RUN" == "true" ]]; then
        log INFO "[DRY RUN] Would mark $file as processed"
        return 0
    fi

    # Add processed marker as HTML comment at end of file
    echo "" >> "$file"
    echo "<!-- ${PROCESSED_MARKER}: ${timestamp} -->" >> "$file"
    log INFO "Marked $file as processed"
}

# Execute AI instruction
execute_instruction() {
    local instruction="$1"
    local note_file="$2"
    local note_name
    note_name=$(basename "$note_file" .md)
    local log_file="${LOG_DIR}/${note_name}-$(date '+%Y%m%d-%H%M%S').log"

    if [[ "$DRY_RUN" == "true" ]]; then
        log OK "[DRY RUN] Would execute: $AI_CLI \"$instruction\""
        return 0
    fi

    log OK "Executing AI instruction from: $note_file"
    log INFO "Instruction: $instruction"
    log INFO "Log file: $log_file"

    # Execute the AI CLI command
    # shellcheck disable=SC2086
    if $AI_CLI "$instruction" > "$log_file" 2>&1; then
        log OK "Successfully executed instruction for: $note_name"
        return 0
    else
        local exit_code=$?
        log ERROR "Failed to execute instruction for: $note_name (exit code: $exit_code)"
        log ERROR "See log: $log_file"
        return 1
    fi
}

# Find and process notes
process_notes() {
    local notes_found=0
    local notes_processed=0
    local notes_skipped=0
    local notes_failed=0

    # Calculate cutoff time
    local cutoff_seconds=$((HOURS_BACK * 3600))
    local cutoff_time
    cutoff_time=$(date -d "-${HOURS_BACK} hours" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || \
                  date -v-${HOURS_BACK}H '+%Y-%m-%d %H:%M:%S' 2>/dev/null)

    log INFO "Scanning vault: $VAULT_PATH"
    log INFO "Looking for tag: $TAG_NAME"
    log INFO "Modified since: $cutoff_time"

    # Find markdown files modified within the time window
    while IFS= read -r -d '' file; do
        ((notes_found++)) || true

        log INFO "Checking: $file"

        # Check for tag
        if ! has_tag "$file"; then
            log INFO "  No matching tag, skipping"
            continue
        fi

        # Check if already processed
        if is_processed "$file"; then
            log INFO "  Already processed, skipping"
            ((notes_skipped++)) || true
            continue
        fi

        # Extract instructions
        local instructions
        if ! instructions=$(extract_instructions "$file"); then
            log WARN "  Has tag but no AI instructions found in: $file"
            continue
        fi

        if [[ -z "$instructions" ]]; then
            log WARN "  Empty instructions in: $file"
            continue
        fi

        log OK "Found work item: $(basename "$file")"

        # Execute instruction
        if execute_instruction "$instructions" "$file"; then
            mark_processed "$file"
            ((notes_processed++)) || true
        else
            ((notes_failed++)) || true
        fi

    done < <(find "$VAULT_PATH" -name "*.md" -type f -mmin -$((HOURS_BACK * 60)) -print0 2>/dev/null)

    # Summary
    echo ""
    log OK "=== Summary ==="
    log OK "Notes scanned: $notes_found"
    log OK "Notes processed: $notes_processed"
    log OK "Notes skipped (already processed): $notes_skipped"
    if [[ $notes_failed -gt 0 ]]; then
        log ERROR "Notes failed: $notes_failed"
    fi

    return 0
}

main() {
    log OK "ia-work starting..."

    # Validate vault exists
    if [[ ! -d "$VAULT_PATH" ]]; then
        log ERROR "Vault path does not exist: $VAULT_PATH"
        exit 1
    fi

    # Ensure Obsidian is running if requested
    ensure_obsidian_running

    # Process notes
    process_notes

    log OK "ia-work complete"
}

main
