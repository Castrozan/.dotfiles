#!/usr/bin/env bash
# speed-read: RSVP (Rapid Serial Visual Presentation) speed reader
# Displays text one word at a time with ORP (Optimal Recognition Point) highlighting
# Based on Spritz-like functionality for terminal

set -euo pipefail

# Default settings
WPM="${SPEED_READ_WPM:-400}"
FOCUS_COLOR="${SPEED_READ_FOCUS_COLOR:-1}"  # Red (ANSI 256 color)
SHOW_POINTER="${SPEED_READ_POINTER:-true}"
PAUSE_ON_PUNCTUATION="${SPEED_READ_PAUSE_PUNCT:-true}"
CENTER_WIDTH="${SPEED_READ_WIDTH:-40}"
WAIT_FOR_START="${SPEED_READ_WAIT:-false}"
WAIT_AT_END="${SPEED_READ_WAIT_END:-false}"

# Colors
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

usage() {
    cat <<EOF
Usage: speed-read [OPTIONS] [FILE]
       echo "text" | speed-read [OPTIONS]

RSVP speed reader with ORP (Optimal Recognition Point) highlighting.
Reads text one word at a time for faster reading (up to 900+ WPM).

Options:
    -w, --wpm N         Words per minute (default: 400, range: 100-1500)
    -c, --color N       ANSI 256 focus color (default: 1/red)
    -p, --no-pointer    Hide the focus pointer
    -P, --no-pause      Don't pause on punctuation
    --wait              Wait for ENTER before starting
    --wait-end          Wait for ENTER after finishing
    --help              Show this help message

Keyboard Controls:
    SPACE / p           Pause/resume
    q / ESC             Quit
    + / =               Increase speed by 50 WPM
    - / _               Decrease speed by 50 WPM
    r                   Restart from beginning

Environment Variables:
    SPEED_READ_WPM           Same as --wpm
    SPEED_READ_FOCUS_COLOR   Same as --color
    SPEED_READ_POINTER       Show pointer (true/false)
    SPEED_READ_PAUSE_PUNCT   Pause on punctuation (true/false)

Examples:
    speed-read document.txt
    echo "This is a test sentence for speed reading." | speed-read
    cat article.md | speed-read --wpm 600
    speed-read --wpm 300 --color 2  # Green focus letter

EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -w|--wpm)
            WPM="$2"
            shift 2
            ;;
        -c|--color)
            FOCUS_COLOR="$2"
            shift 2
            ;;
        -p|--no-pointer)
            SHOW_POINTER="false"
            shift
            ;;
        -P|--no-pause)
            PAUSE_ON_PUNCTUATION="false"
            shift
            ;;
        --wait)
            WAIT_FOR_START="true"
            shift
            ;;
        --wait-end)
            WAIT_AT_END="true"
            shift
            ;;
        --help)
            usage
            exit 0
            ;;
        -*)
            echo "Unknown option: $1" >&2
            usage
            exit 1
            ;;
        *)
            INPUT_FILE="$1"
            shift
            ;;
    esac
done

# Validate WPM
if [[ ! "$WPM" =~ ^[0-9]+$ ]] || [[ "$WPM" -lt 50 ]] || [[ "$WPM" -gt 2000 ]]; then
    echo "Error: WPM must be between 50 and 2000" >&2
    exit 1
fi

# Calculate delay in seconds (with decimals)
calculate_delay() {
    local wpm="$1"
    # 60 seconds / WPM = seconds per word
    # Using bc for floating point
    echo "scale=4; 60 / $wpm" | bc
}

# Get ORP (Optimal Recognition Point) position for a word
# Based on word length, the ORP is typically around 1/3 from the left
get_orp_position() {
    local word="$1"
    local len=${#word}

    case $len in
        1) echo 0 ;;
        2|3) echo 1 ;;
        4|5) echo 1 ;;
        6|7) echo 2 ;;
        8|9) echo 2 ;;
        10|11) echo 3 ;;
        12|13) echo 3 ;;
        *) echo $(( (len - 1) / 3 )) ;;
    esac
}

# Format word with ORP highlighting
format_word() {
    local word="$1"
    local orp_pos
    orp_pos=$(get_orp_position "$word")
    local len=${#word}

    # Calculate padding for center alignment based on ORP
    local pad_left=$(( (CENTER_WIDTH / 2) - orp_pos ))
    [[ $pad_left -lt 0 ]] && pad_left=0

    # Build the formatted word
    local before="${word:0:$orp_pos}"
    local focus="${word:$orp_pos:1}"
    local after="${word:$((orp_pos + 1))}"

    # ANSI color for focus letter
    local focus_colored="\033[38;5;${FOCUS_COLOR}m${BOLD}${focus}${RESET}"

    # Print with padding
    printf "%${pad_left}s" ""
    printf "${DIM}%s${RESET}${focus_colored}${DIM}%s${RESET}" "$before" "$after"
}

# Display pointer line
display_pointer() {
    if [[ "$SHOW_POINTER" == "true" ]]; then
        local pad=$(( CENTER_WIDTH / 2 ))
        printf "%${pad}s\n" "|"
    fi
}

# Check if word ends with punctuation (for pause)
has_punctuation() {
    local word="$1"
    local punct_pattern='[.!?,;:—–-]$'
    [[ "$word" =~ $punct_pattern ]]
}

# Clean word of markdown/special characters but keep punctuation for pause detection
clean_word() {
    local word="$1"
    # Remove markdown formatting but keep core word
    echo "$word" | sed -E 's/^[\*_#\[\]`]+//; s/[\*_#\[\]`]+$//'
}

# Hide cursor
hide_cursor() {
    tput civis 2>/dev/null || printf '\033[?25l'
}

# Show cursor
show_cursor() {
    tput cnorm 2>/dev/null || printf '\033[?25h'
}

# Clear line
clear_line() {
    printf '\r\033[K'
}

# Handle exit
cleanup() {
    # Restore tty settings if we changed them
    if [[ -n "${SAVED_STTY:-}" ]]; then
        if [[ "${USE_DEV_TTY:-true}" == "true" ]] && [[ -e /dev/tty ]]; then
            stty "$SAVED_STTY" </dev/tty 2>/dev/null || true
        else
            stty "$SAVED_STTY" 2>/dev/null || true
        fi
    fi
    show_cursor
    clear_line
    echo ""
    exit 0
}

trap cleanup EXIT INT TERM

# Read input
if [[ -n "${INPUT_FILE:-}" ]]; then
    if [[ ! -f "$INPUT_FILE" ]]; then
        echo "Error: File not found: $INPUT_FILE" >&2
        exit 1
    fi
    TEXT=$(cat "$INPUT_FILE")
else
    # Read from stdin
    if [[ -t 0 ]]; then
        echo "Error: No input provided. Pipe text or provide a file." >&2
        usage
        exit 1
    fi
    TEXT=$(cat)
fi

# Convert text to array of words
# shellcheck disable=SC2206
WORDS=($TEXT)
TOTAL_WORDS=${#WORDS[@]}

if [[ $TOTAL_WORDS -eq 0 ]]; then
    echo "Error: No words to display" >&2
    exit 1
fi

# Display info header
echo ""
echo "Speed Reader - ${WPM} WPM | ${TOTAL_WORDS} words | ~$(( TOTAL_WORDS * 60 / WPM ))s"
echo "Controls: [SPACE] pause | [+/-] speed | [q] quit | [r] restart"
echo ""

# Show pointer if enabled
display_pointer

# Hide cursor for cleaner display
hide_cursor

# Main display loop
PAUSED=false
CURRENT_WPM=$WPM
WORD_INDEX=0

# Set up non-blocking input
# Use stdin if it's a tty (file input), otherwise use /dev/tty (piped input)
if [[ -t 0 ]]; then
    # stdin is a tty - use it directly
    SAVED_STTY=$(stty -g)
    stty -echo -icanon min 0 time 0
    USE_DEV_TTY=false
    TTY_AVAILABLE=true
elif [[ -t 1 ]] && [[ -e /dev/tty ]]; then
    # stdin is piped but we have /dev/tty
    SAVED_STTY=$(stty -g </dev/tty)
    stty -echo -icanon min 0 time 0 </dev/tty
    USE_DEV_TTY=true
    TTY_AVAILABLE=true
else
    TTY_AVAILABLE=false
    USE_DEV_TTY=false
fi

# Helper function to read a key
read_key() {
    local timeout="${1:-}"
    if [[ "$USE_DEV_TTY" == "true" ]]; then
        if [[ -n "$timeout" ]]; then
            read -r -n 1 -t "$timeout" key </dev/tty 2>/dev/null || true
        else
            read -r -n 1 key </dev/tty 2>/dev/null || true
        fi
    else
        if [[ -n "$timeout" ]]; then
            read -r -n 1 -t "$timeout" key 2>/dev/null || true
        else
            read -r -n 1 key 2>/dev/null || true
        fi
    fi
}

# Wait for Enter before starting if --wait flag is set
if [[ "$WAIT_FOR_START" == "true" ]] && [[ "$TTY_AVAILABLE" == "true" ]]; then
    printf "Press ENTER to start reading..."
    while true; do
        key=""
        read_key
        # Enter key produces empty string in raw mode
        [[ -z "$key" ]] && break
    done
    clear_line
fi

while [[ $WORD_INDEX -lt $TOTAL_WORDS ]]; do
    # Get current word
    WORD="${WORDS[$WORD_INDEX]}"
    CLEAN_WORD=$(clean_word "$WORD")

    # Skip empty words
    if [[ -z "$CLEAN_WORD" ]]; then
        ((WORD_INDEX++)) || true
        continue
    fi

    # Display the word
    clear_line
    format_word "$CLEAN_WORD"

    # Calculate delay in milliseconds for the wait loop
    DELAY=$(calculate_delay "$CURRENT_WPM")

    # Add extra delay for punctuation
    if [[ "$PAUSE_ON_PUNCTUATION" == "true" ]] && has_punctuation "$CLEAN_WORD"; then
        DELAY=$(echo "scale=4; $DELAY * 2.5" | bc)
    fi

    # Wait while checking for keypresses (check every 0.05s)
    WAIT_REMAINING="$DELAY"
    while (( $(echo "$WAIT_REMAINING > 0" | bc -l) )); do
        key=""
        if [[ "$TTY_AVAILABLE" == "true" ]]; then
            read_key 0.05
        else
            sleep 0.05
        fi

        # Handle keypress if detected
        if [[ -n "$key" ]]; then
            case "$key" in
                ' '|p|P)
                    clear_line
                    printf "  [PAUSED - ${CURRENT_WPM} WPM - Word %d/%d - Press SPACE to continue]" "$((WORD_INDEX + 1))" "$TOTAL_WORDS"
                    while true; do
                        key=""
                        read_key 0.1
                        case "$key" in
                            ' '|p|P) break ;;
                            q|Q|$'\e') cleanup ;;
                        esac
                    done
                    clear_line
                    format_word "$CLEAN_WORD"
                    ;;
                +|=)
                    CURRENT_WPM=$((CURRENT_WPM + 50))
                    [[ $CURRENT_WPM -gt 2000 ]] && CURRENT_WPM=2000
                    ;;
                -|_)
                    CURRENT_WPM=$((CURRENT_WPM - 50))
                    [[ $CURRENT_WPM -lt 50 ]] && CURRENT_WPM=50
                    ;;
                r|R)
                    WORD_INDEX=0
                    WAIT_REMAINING=0
                    continue 2
                    ;;
                q|Q|$'\e')
                    cleanup
                    ;;
            esac
        fi

        WAIT_REMAINING=$(echo "scale=4; $WAIT_REMAINING - 0.05" | bc)
    done

    ((WORD_INDEX++)) || true
done

# Finished
clear_line
echo ""
echo "Done! Read ${TOTAL_WORDS} words at ~${CURRENT_WPM} WPM"

# Wait for Enter at end if --wait-end flag is set
if [[ "$WAIT_AT_END" == "true" ]] && [[ "$TTY_AVAILABLE" == "true" ]]; then
    echo ""
    printf "Press ENTER to close..."
    while true; do
        key=""
        read_key
        [[ -z "$key" ]] && break
    done
fi

show_cursor
