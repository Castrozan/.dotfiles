#!/usr/bin/env bash
# speed-read: RSVP (Rapid Serial Visual Presentation) speed reader
# Displays text one word at a time with ORP (Optimal Recognition Point) highlighting

set -euo pipefail

# Default settings
WPM="${SPEED_READ_WPM:-400}"
FOCUS_COLOR="${SPEED_READ_FOCUS_COLOR:-1}"  # Red (ANSI 256 color)
SHOW_POINTER="${SPEED_READ_POINTER:-true}"
PAUSE_ON_PUNCTUATION="${SPEED_READ_PAUSE_PUNCT:-true}"
CENTER_WIDTH="${SPEED_READ_WIDTH:-40}"
WAIT_FOR_START="${SPEED_READ_WAIT:-false}"
WAIT_AT_END="${SPEED_READ_WAIT_END:-false}"

# Colors
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

usage() {
    cat <<EOF
Usage: speed-read [OPTIONS] [FILE]
       echo "text" | speed-read [OPTIONS]

RSVP speed reader with ORP (Optimal Recognition Point) highlighting.
Reads text one word at a time for faster reading (up to 900+ WPM).

Options:
    -w, --wpm N         Words per minute (default: 400, range: 100-1500)
    -c, --color N       ANSI 256 focus color (default: 1/red)
    -p, --no-pointer    Hide the focus pointer
    -P, --no-pause      Don't pause on punctuation
    --wait              Wait for ENTER before starting
    --wait-end          Wait for ENTER after finishing
    --help              Show this help message

Keyboard Controls:
    SPACE / p           Pause/resume
    q / ESC             Quit
    + / =               Increase speed by 50 WPM
    - / _               Decrease speed by 50 WPM
    r                   Restart from beginning

Environment Variables:
    SPEED_READ_WPM           Same as --wpm
    SPEED_READ_FOCUS_COLOR   Same as --color
    SPEED_READ_POINTER       Show pointer (true/false)
    SPEED_READ_PAUSE_PUNCT   Pause on punctuation (true/false)

Examples:
    speed-read document.txt
    echo "This is a test sentence for speed reading." | speed-read
    cat article.md | speed-read --wpm 600
    speed-read --wpm 300 --color 2  # Green focus letter

EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -w|--wpm)
            WPM="$2"
            shift 2
            ;;
        -c|--color)
            FOCUS_COLOR="$2"
            shift 2
            ;;
        -p|--no-pointer)
            SHOW_POINTER="false"
            shift
            ;;
        -P|--no-pause)
            PAUSE_ON_PUNCTUATION="false"
            shift
            ;;
        --wait)
            WAIT_FOR_START="true"
            shift
            ;;
        --wait-end)
            WAIT_AT_END="true"
            shift
            ;;
        --help)
            usage
            exit 0
            ;;
        -*)
            echo "Unknown option: $1" >&2
            usage
            exit 1
            ;;
        *)
            INPUT_FILE="$1"
            shift
            ;;
    esac
done

# Validate WPM
if [[ ! "$WPM" =~ ^[0-9]+$ ]] || [[ "$WPM" -lt 50 ]] || [[ "$WPM" -gt 2000 ]]; then
    echo "Error: WPM must be between 50 and 2000" >&2
    exit 1
fi

# Calculate delay intervals (each interval is 0.1s)
# Formula: 600 / WPM (since 60s * 10 intervals/s = 600 intervals/min)
calculate_intervals() {
    local wpm="$1"
    local intervals=$(( 600 / wpm ))
    [[ $intervals -lt 1 ]] && intervals=1
    echo "$intervals"
}

# Get ORP (Optimal Recognition Point) position for a word
get_orp_position() {
    local word="$1"
    local len=${#word}
    case $len in
        1) echo 0 ;;
        2|3) echo 1 ;;
        4|5) echo 1 ;;
        6|7) echo 2 ;;
        8|9) echo 2 ;;
        10|11) echo 3 ;;
        12|13) echo 3 ;;
        *) echo $(( (len - 1) / 3 )) ;;
    esac
}

# Format word with ORP highlighting
format_word() {
    local word="$1"
    local orp_pos
    orp_pos=$(get_orp_position "$word")
    local len=${#word}
    local pad_left=$(( (CENTER_WIDTH / 2) - orp_pos ))
    [[ $pad_left -lt 0 ]] && pad_left=0

    local before="${word:0:$orp_pos}"
    local focus="${word:$orp_pos:1}"
    local after="${word:$((orp_pos + 1))}"
    local focus_colored="\033[38;5;${FOCUS_COLOR}m${BOLD}${focus}${RESET}"

    printf "%${pad_left}s" ""
    printf "${DIM}%s${RESET}${focus_colored}${DIM}%s${RESET}" "$before" "$after"
}

# Display pointer line
display_pointer() {
    if [[ "$SHOW_POINTER" == "true" ]]; then
        local pad=$(( CENTER_WIDTH / 2 ))
        printf "%${pad}s\n" "|"
    fi
}

# Check if word ends with punctuation
has_punctuation() {
    local word="$1"
    local punct_pattern='[.!?,;:—–-]$'
    [[ "$word" =~ $punct_pattern ]]
}

# Clean word of markdown/special characters
clean_word() {
    local word="$1"
    echo "$word" | sed -E 's/^[\*_#\[\]`]+//; s/[\*_#\[\]`]+$//'
}

hide_cursor() { printf '\033[?25l'; }
show_cursor() { printf '\033[?25h'; }
clear_line() { printf '\r\033[K'; }

cleanup() {
    show_cursor
    stty sane 2>/dev/null || true
    clear_line
    echo ""
    exit 0
}
trap cleanup EXIT INT TERM

# Read input
if [[ -n "${INPUT_FILE:-}" ]]; then
    if [[ ! -f "$INPUT_FILE" ]]; then
        echo "Error: File not found: $INPUT_FILE" >&2
        exit 1
    fi
    TEXT=$(cat "$INPUT_FILE")
else
    if [[ -t 0 ]]; then
        echo "Error: No input provided. Pipe text or provide a file." >&2
        usage
        exit 1
    fi
    TEXT=$(cat)
fi

# Convert text to array of words
# shellcheck disable=SC2206
WORDS=($TEXT)
TOTAL_WORDS=${#WORDS[@]}

if [[ $TOTAL_WORDS -eq 0 ]]; then
    echo "Error: No words to display" >&2
    exit 1
fi

# Display info header
echo ""
echo "Speed Reader - ${WPM} WPM | ${TOTAL_WORDS} words | ~$(( TOTAL_WORDS * 60 / WPM ))s"
echo "Controls: [SPACE] pause | [+/-] speed | [q] quit | [r] restart"
echo ""

display_pointer
hide_cursor

# Setup terminal for key reading
stty -echo -icanon min 0 time 0

# Wait for Enter before starting if --wait flag is set
if [[ "$WAIT_FOR_START" == "true" ]]; then
    printf "Press ENTER to start reading..."
    while true; do
        key=""
        read -r -n 1 key || true
        [[ -z "$key" ]] && break
    done
    clear_line
fi

# Main variables
CURRENT_WPM=$WPM
WORD_INDEX=0

# Main reading loop
while [[ $WORD_INDEX -lt $TOTAL_WORDS ]]; do
    WORD="${WORDS[$WORD_INDEX]}"
    CLEAN_WORD=$(clean_word "$WORD")

    # Skip empty words
    if [[ -z "$CLEAN_WORD" ]]; then
        ((WORD_INDEX++)) || true
        continue
    fi

    # Display the word
    clear_line
    format_word "$CLEAN_WORD"

    # Calculate delay intervals
    INTERVALS=$(calculate_intervals "$CURRENT_WPM")

    # Extra delay for punctuation
    if [[ "$PAUSE_ON_PUNCTUATION" == "true" ]] && has_punctuation "$CLEAN_WORD"; then
        INTERVALS=$((INTERVALS * 2))
    fi

    # Wait while checking for keypresses (0.1s per interval)
    for ((i=0; i<INTERVALS; i++)); do
        key=""
        read -r -n 1 -t 0.1 key || true

        if [[ -n "$key" ]]; then
            case "$key" in
                ' '|p|P)
                    clear_line
                    printf "  [PAUSED - ${CURRENT_WPM} WPM - Word %d/%d - Press SPACE to continue]" "$((WORD_INDEX + 1))" "$TOTAL_WORDS"
                    while true; do
                        key=""
                        read -r -n 1 key || true
                        case "$key" in
                            ' '|p|P) break ;;
                            q|Q) cleanup ;;
                        esac
                    done
                    clear_line
                    format_word "$CLEAN_WORD"
                    ;;
                +|=)
                    CURRENT_WPM=$((CURRENT_WPM + 50))
                    [[ $CURRENT_WPM -gt 2000 ]] && CURRENT_WPM=2000
                    ;;
                -|_)
                    CURRENT_WPM=$((CURRENT_WPM - 50))
                    [[ $CURRENT_WPM -lt 50 ]] && CURRENT_WPM=50
                    ;;
                r|R)
                    WORD_INDEX=0
                    continue 2
                    ;;
                q|Q|$'\e')
                    cleanup
                    ;;
            esac
        fi
    done

    ((WORD_INDEX++)) || true
done

# Finished
clear_line
echo ""
echo "Done! Read ${TOTAL_WORDS} words at ~${CURRENT_WPM} WPM"

# Wait for Enter at end if --wait-end flag is set
if [[ "$WAIT_AT_END" == "true" ]]; then
    echo ""
    printf "Press ENTER to close..."
    while true; do
        key=""
        read -r -n 1 key || true
        [[ -z "$key" ]] && break
    done
fi

show_cursor
