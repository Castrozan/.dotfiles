#!/usr/bin/env bash
# Automated Claude Code session renaming service
# Scans sessions-index.json files and generates short descriptive names using Claude CLI

set -euo pipefail

CLAUDE_DIR="${HOME}/.claude"
PROJECTS_DIR="${CLAUDE_DIR}/projects"
MAX_NAME_LENGTH="${CLAUDE_SESSION_RENAME_MAX_LENGTH:-50}"
MIN_PROMPT_LENGTH="${CLAUDE_SESSION_RENAME_MIN_LENGTH:-60}"
MARKER_PREFIX="[r] "
VERBOSE="${CLAUDE_SESSION_RENAME_VERBOSE:-false}"
DRY_RUN="${CLAUDE_SESSION_RENAME_DRY_RUN:-false}"

log() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo "[$(date '+%H:%M:%S')] $*" >&2
    fi
}

log_always() {
    echo "[$(date '+%H:%M:%S')] $*" >&2
}

# Check if a session needs renaming
needs_renaming() {
    local first_prompt="$1"

    # Already renamed (has marker prefix)
    if [[ "$first_prompt" == "$MARKER_PREFIX"* ]]; then
        return 1
    fi

    # Short prompts don't need renaming
    if [[ ${#first_prompt} -lt $MIN_PROMPT_LENGTH ]]; then
        return 1
    fi

    return 0
}

# Get first user message from session JSONL file
get_first_user_message() {
    local session_file="$1"

    if [[ ! -f "$session_file" ]]; then
        return 1
    fi

    # Extract first user message content (grep for type:user, then extract message content)
    # The session file is JSONL - each line is a JSON object
    grep -m1 '"type":"user"' "$session_file" 2>/dev/null | \
        jq -r '.message.content // empty' 2>/dev/null | \
        head -c 2000
}

# Generate a short name using Claude CLI
generate_name() {
    local content="$1"
    local prompt="You are a title generator. Output ONLY a short title, nothing else.

INPUT:
${content}

OUTPUT FORMAT: Just the title (3-7 words max). No explanations. No markdown. No quotes.

BAD outputs (DO NOT DO THIS):
- 'Perfect! I've created...' (conversational)
- '## Summary...' (markdown)
- 'Here is the title: ...' (explanation)

GOOD outputs:
- Configurar hooks no Claude Code
- Fix login redirect bug
- Serviço auto-rename sessões

YOUR TITLE:"

    local result
    if ! result=$(claude -p "$prompt" --model claude-sonnet-4-20250514 2>/dev/null); then
        log "Claude CLI failed"
        return 1
    fi

    # Clean up result: remove markdown, conversational prefixes, trim whitespace
    result=$(echo "$result" | \
        tr -d '\n' | \
        sed 's/^#\+[[:space:]]*//g' | \
        sed 's/^\*\+[[:space:]]*//g' | \
        sed 's/^Summary[[:space:]]*[:：-]*[[:space:]]*//i' | \
        sed 's/^Title[[:space:]]*[:：-]*[[:space:]]*//i' | \
        sed 's/^Perfect![[:space:]]*//i' | \
        sed 's/^Great![[:space:]]*//i' | \
        sed 's/^Here is[^:]*:[[:space:]]*//i' | \
        sed "s/^I've [^:]*:[[:space:]]*//i" | \
        sed "s/^['\"\`]//;s/['\"\`]$//" | \
        sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | \
        head -c "$MAX_NAME_LENGTH")

    if [[ -z "$result" ]]; then
        log "Empty result from Claude"
        return 1
    fi

    echo "$result"
}

# Update session name in index file
update_session_name() {
    local index_file="$1"
    local session_id="$2"
    local new_name="$3"

    local marked_name="${MARKER_PREFIX}${new_name}"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_always "[DRY-RUN] Would rename $session_id to: $marked_name"
        return 0
    fi

    local tmp_file
    tmp_file=$(mktemp)

    if jq --arg sid "$session_id" --arg name "$marked_name" \
        '(.entries[] | select(.sessionId == $sid) | .firstPrompt) = $name' \
        "$index_file" > "$tmp_file" 2>/dev/null; then
        mv "$tmp_file" "$index_file"
        log_always "Renamed $session_id: $marked_name"
        return 0
    else
        rm -f "$tmp_file"
        log "Failed to update index file"
        return 1
    fi
}

# Process a single project directory
process_project() {
    local project_dir="$1"
    local index_file="${project_dir}/sessions-index.json"

    if [[ ! -f "$index_file" ]]; then
        log "No sessions-index.json in $project_dir"
        return 0
    fi

    log "Processing: $index_file"

    # Read all sessions that might need renaming
    local sessions
    sessions=$(jq -r '.entries[] | "\(.sessionId)|\(.firstPrompt)"' "$index_file" 2>/dev/null) || return 0

    local count=0
    while IFS='|' read -r session_id first_prompt; do
        [[ -z "$session_id" ]] && continue

        if ! needs_renaming "$first_prompt"; then
            log "Skipping $session_id (already processed or short)"
            continue
        fi

        log "Processing session: $session_id"

        # Find session file
        local session_file="${project_dir}/${session_id}.jsonl"

        # Get content for naming
        local content
        if [[ -f "$session_file" ]]; then
            content=$(get_first_user_message "$session_file")
        fi

        # Fallback to firstPrompt if can't read session file
        if [[ -z "${content:-}" ]]; then
            content="$first_prompt"
        fi

        # Generate new name
        local new_name
        if new_name=$(generate_name "$content"); then
            update_session_name "$index_file" "$session_id" "$new_name"
            ((count++))
        else
            log "Failed to generate name for $session_id"
        fi

        # Small delay between API calls
        sleep 1

    done <<< "$sessions"

    if [[ $count -gt 0 ]]; then
        log_always "Processed $count sessions in $(basename "$project_dir")"
    fi
}

main() {
    if [[ ! -d "$PROJECTS_DIR" ]]; then
        log "No projects directory found: $PROJECTS_DIR"
        exit 0
    fi

    # Check if claude CLI is available
    if ! command -v claude &>/dev/null; then
        log_always "Error: claude CLI not found in PATH"
        exit 1
    fi

    log_always "Starting session rename scan..."

    # Process each project directory
    for project_dir in "$PROJECTS_DIR"/*/; do
        [[ -d "$project_dir" ]] || continue
        process_project "$project_dir"
    done

    log_always "Session rename scan complete"
}

main "$@"
